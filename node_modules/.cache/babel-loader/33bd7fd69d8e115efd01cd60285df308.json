{"ast":null,"code":"import _toConsumableArray from \"/Users/kycklingbror/Desktop/Github_Repos/ABCgame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _objectSpread from \"/Users/kycklingbror/Desktop/Github_Repos/ABCgame/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { assign, send } from \"xstate\"; //Instantiate a new obj for each new round of game\n\nimport { makeNewQuestions, randomChoice } from './game_codes/game'; // let qs=makeNewQuestions()\n// console.log(qs.letter)\n// console.log(qs.ques)\n//Using \"Natural\" NLP library\n\nvar natural = require('natural'),\n    nounInflector = new natural.NounInflector(); // let singular = nounInflector.singularize('those tomatoes');\n// console.log(singular); //>>those tomato\n\n\nvar clearRecResult = assign(function (context) {\n  return {\n    recResult: ''\n  };\n});\nvar clearTTSAgenda = assign(function (context) {\n  return {\n    ttsAgenda: ''\n  };\n});\nvar resetTally = assign(function (context) {\n  return {\n    tally: undefined\n  };\n});\nvar clearLetter = assign(function (context) {\n  return {\n    letter: undefined\n  };\n});\nvar confettiOn = assign(function (context) {\n  return {\n    confettiSwitch: true\n  };\n});\nvar confettiOff = assign(function (context) {\n  return {\n    confettiSwitch: false\n  };\n});\nvar gameOn = assign(function (context) {\n  return {\n    playingNow: true\n  };\n});\nvar gameOff = assign(function (context) {\n  return {\n    playingNow: false\n  };\n}); //Initiate a questions object & assign values to context.letter/questions/tally\n\nvar newGameRound = assign(function (context) {\n  var qs = makeNewQuestions();\n  return {\n    letter: qs.letter,\n    questions: qs.ques,\n    tally: 0,\n    confettiSwitch: false\n  };\n}); //Say the current random letter and a 'spelling/phonetic' alphabet\n\nfunction letterNow(context) {\n  var alphabet = {\n    'a': 'Adam',\n    'b': 'Bella',\n    'c': 'Cindy',\n    'd': 'Daniel',\n    'e': 'Eva',\n    'f': 'Francesca',\n    'g': 'Gabriel',\n    'h': 'Harry',\n    'i': 'Ida',\n    'j': 'Julia',\n    'k': 'Kevin',\n    'l': 'Laura',\n    'm': 'Michael',\n    'n': 'Nicole',\n    'o': 'Oscar',\n    'p': 'Paula',\n    'q': 'Quebec',\n    'r': 'Rachel',\n    's': 'Sara',\n    't': 'Tina',\n    'u': 'unique',\n    'v': 'Victoria',\n    'w': 'window',\n    'x': 'x-ray',\n    'y': 'yesman',\n    'z': 'zero'\n  };\n  var letter = context.letter;\n  return \"Your letter is \".concat(letter.toUpperCase(), \" for \").concat(alphabet[letter], \". \");\n}\n\nfunction questionNow(context) {\n  var category = context.questions[0].category; //the question at front of array\n\n  return \"Name \".concat(category, \". \");\n}\n\nfunction giveHint(context) {\n  var answers = context.questions[0].answers; //answers to the question at front of array\n\n  var anAns = randomChoice(answers);\n\n  if (anAns.length >= 3) {\n    var hint = anAns.slice(0, 3).toUpperCase(); //first 3 letters\n\n    return \"Spelled with \".concat(hint[0], \", \").concat(hint[1], \", \").concat(hint[2], \".\");\n  } //in case word is too short>>hint only 2 letters\n  else {\n      var _hint = anAns.slice(0, 2).toUpperCase(); //first 2 letters\n\n\n      return \"Spelled with \".concat(_hint[0], \", \").concat(_hint[1], \", \").concat(_hint[2], \".\");\n    }\n} //Partial match of user input, as long as input mentions an answer\n\n\nfunction answerMatches(input, context) {\n  var reply = input.toLowerCase(); //convert to lowercase\n\n  var replySing = nounInflector.singularize(reply); //convert to singular form\n\n  var answers = context.questions[0].answers; //answers to the question at front of array\n  //True if reply--either original or singularised--mentions an answer \n  //(eg, 'the Netherlands' matches 'netherlands'; 'these strawberries' matches 'strawberry')\n\n  return exists(reply, answers) || exists(replySing, answers);\n}\n\nfunction say(text) {\n  return send(function (_context) {\n    return {\n      type: \"SPEAK\",\n      value: text\n    };\n  });\n}\n\nfunction sharedRecognitions() {\n  return [{\n    target: 'stop',\n    cond: function cond(context) {\n      return sayKeyword(context.recResult) === 'stop';\n    }\n  }, {\n    target: 'restart',\n    cond: function cond(context) {\n      return sayKeyword(context.recResult) === 'restart';\n    }\n  }, //for testing \n  {\n    target: 'winning',\n    cond: function cond(context) {\n      return sayKeyword(context.recResult) === 'shortcut';\n    }\n  }, {\n    target: \".nomatch\"\n  }];\n}\n\nfunction promptAndAsk(promptEvent) {\n  return {\n    initial: 'prompt',\n    states: {\n      prompt: {\n        entry: promptEvent,\n        on: {\n          ENDSPEECH: 'ask'\n        }\n      },\n      ask: {\n        entry: send('LISTEN')\n      },\n      nomatch: {\n        entry: [say(\"Try again\")],\n        on: {\n          ENDSPEECH: \"prompt\"\n        }\n      }\n    }\n  };\n} // Similar to python: any(keyword in input for keyword in keywords)\n\n\nfunction exists(input, keywords) {\n  var existence = keywords.some(function (keyword) {\n    return input.includes(keyword);\n  });\n  return existence;\n} //Replace this with grammar parser?\n\n\nfunction sayKeyword(reply) {\n  var yes = [\"yes\", \"of course\", \"sure\", \"absolutely\", \"yeah\", \"yep\", \"okay\", \"ok\"];\n  var no = [\"no\", \"nope\", \"no thanks\", \"nah\"];\n  var pass = [\"skip\", \"pass\", \"next\"];\n  var hint = [\"hint\", \"clue\", \"help\"];\n  var whatletter = ['letter', 'repeat'];\n  var stop = ['stop', 'end the game', 'shut down'];\n  var restart = ['restart', 'start again', 'reboot'];\n  var shortcut = ['short cut', 'shortcut']; //for testing\n\n  reply = reply.toLowerCase();\n\n  if (exists(reply, yes)) {\n    return 'yes';\n  }\n\n  if (exists(reply, no)) {\n    return 'no';\n  }\n\n  if (exists(reply, pass)) {\n    return 'pass';\n  }\n\n  if (exists(reply, hint)) {\n    return 'hint';\n  }\n\n  if (exists(reply, whatletter)) {\n    return 'whatletter';\n  }\n\n  if (exists(reply, stop)) {\n    return 'stop';\n  }\n\n  if (exists(reply, restart)) {\n    return 'restart';\n  }\n\n  if (exists(reply, shortcut)) {\n    return 'shortcut';\n  } //for testing\n\n}\n/*\nNOTES\nSwear words are censored so won't match. Unless change them to f*** in the JSON\n? Find out how to show prompts & recognised text on screen\n? Confetti effect in winning state\n! Need to lemmatize userinput. Use js-lemmatizer, Natural, and/or Wink libraries \n*/\n\n\nexport var dmMachine = {\n  initial: 'init',\n  states: {\n    init: {\n      on: {\n        CLICK: 'start'\n      }\n    },\n    stop: {\n      entry: say(\"Ok bye!\"),\n      on: {\n        ENDSPEECH: {\n          actions: [resetTally, clearLetter, clearTTSAgenda, clearRecResult, confettiOff],\n          target: \"init\"\n        }\n      }\n    },\n    //Start new game: initiate new game object & reset tally counter\n    start: {\n      entry: say(\"Starting the game \"),\n      on: {\n        ENDSPEECH: {\n          actions: [newGameRound, gameOn, clearTTSAgenda, clearRecResult],\n          target: \"sayletter\"\n        }\n      }\n    },\n    restart: {\n      entry: say(\"Ok, starting over\"),\n      // always: 'sayletter'\n      on: {\n        ENDSPEECH: {\n          actions: [newGameRound, clearTTSAgenda, clearRecResult],\n          target: \"sayletter\"\n        }\n      }\n    },\n    //Say the letter\n    sayletter: {\n      entry: send(function (context) {\n        return {\n          type: \"SPEAK\",\n          value: letterNow(context)\n        };\n      }),\n      on: {\n        ENDSPEECH: 'askQues'\n      }\n    },\n    //Ask 5 (or more if skipping) questions \n    askQues: _objectSpread({\n      on: {\n        RECOGNISED: [// ? Clear recResult after recognition or not...?\n        // If answer matches answers, tally+=1, shift question[0]\n        {\n          cond: function cond(context) {\n            return answerMatches(context.recResult, context);\n          },\n          actions: assign(function (context) {\n            context.questions.shift();\n            return {\n              tally: context.tally + 1\n            };\n          }),\n          target: \"checkscore\"\n        }, //If pass, move the question to the last (unshift & push)\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'pass';\n          },\n          actions: assign(function (context) {\n            var skipped = context.questions.shift();\n            context.questions.push(skipped);\n            return {};\n          }),\n          target: \"checkscore\"\n        }, //Hint 3 or 2 letters\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'hint';\n          },\n          target: \"hint\"\n        }, //Repeat letter\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'whatletter';\n          },\n          target: \"sayletter\"\n        }].concat(_toConsumableArray(sharedRecognitions()))\n      }\n    }, promptAndAsk(send(function (context) {\n      return {\n        type: \"SPEAK\",\n        value: questionNow(context)\n      };\n    }))),\n    hint: {\n      entry: send(function (context) {\n        return {\n          type: \"SPEAK\",\n          value: giveHint(context)\n        };\n      }),\n      always: 'checkscore'\n    },\n    checkscore: {\n      always: [//Less than 5 correct\n      {\n        target: 'askQues',\n        cond: function cond(context) {\n          return context.tally < 5;\n        }\n      }, //5 correct\n      {\n        target: 'winning',\n        cond: function cond(context) {\n          return context.tally >= 5;\n        }\n      }]\n    },\n    //? reset/clear tally here or not...? \n    winning: {\n      entry: [say(\"Winner winner chicken dinner\"), confettiOn, clearLetter, clearRecResult, clearTTSAgenda],\n      on: {\n        ENDSPEECH: {\n          target: 'playagain'\n        }\n      }\n    },\n    playagain: _objectSpread({\n      entry: [resetTally, confettiOff],\n      on: {\n        RECOGNISED: [//Play again? restart:stop\n        {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'yes';\n          },\n          target: \"restart\"\n        }, {\n          cond: function cond(context) {\n            return sayKeyword(context.recResult) === 'no';\n          },\n          target: \"stop\"\n        }].concat(_toConsumableArray(sharedRecognitions()))\n      }\n    }, promptAndAsk(say('Want to play again?')))\n  }\n};","map":{"version":3,"sources":["/Users/kycklingbror/Desktop/Github_Repos/ABCgame/src/dmGame.ts"],"names":["assign","send","makeNewQuestions","randomChoice","natural","require","nounInflector","NounInflector","clearRecResult","context","recResult","clearTTSAgenda","ttsAgenda","resetTally","tally","undefined","clearLetter","letter","confettiOn","confettiSwitch","confettiOff","gameOn","playingNow","gameOff","newGameRound","qs","questions","ques","letterNow","alphabet","toUpperCase","questionNow","category","giveHint","answers","anAns","length","hint","slice","answerMatches","input","reply","toLowerCase","replySing","singularize","exists","say","text","_context","type","value","sharedRecognitions","target","cond","sayKeyword","promptAndAsk","promptEvent","initial","states","prompt","entry","on","ENDSPEECH","ask","nomatch","keywords","existence","some","keyword","includes","yes","no","pass","whatletter","stop","restart","shortcut","dmMachine","init","CLICK","actions","start","sayletter","askQues","RECOGNISED","shift","skipped","push","always","checkscore","winning","playagain"],"mappings":"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","sourcesContent":["import { MachineConfig, actions, Action, assign, send } from \"xstate\";\n\n//Instantiate a new obj for each new round of game\nimport { makeNewQuestions, randomChoice } from './game_codes/game'\n// let qs=makeNewQuestions()\n// console.log(qs.letter)\n// console.log(qs.ques)\n\n//Using \"Natural\" NLP library\nconst natural = require('natural'),\nnounInflector = new natural.NounInflector();\n// let singular = nounInflector.singularize('those tomatoes');\n// console.log(singular); //>>those tomato\n\n\nconst clearRecResult: Action<SDSContext, SDSEvent> = assign((context) => { return { recResult:''} })\nconst clearTTSAgenda: Action<SDSContext, SDSEvent> = assign((context) => { return { ttsAgenda:''} })\nconst resetTally: Action<SDSContext, SDSEvent> = assign((context) => { return { tally:undefined} })\nconst clearLetter: Action<SDSContext, SDSEvent> = assign((context) => { return { letter:undefined} })\n\nconst confettiOn: Action<SDSContext, SDSEvent> = assign((context) => { return { confettiSwitch:true} })\nconst confettiOff: Action<SDSContext, SDSEvent> = assign((context) => { return { confettiSwitch:false} })\n\nconst gameOn: Action<SDSContext, SDSEvent> = assign((context) => { return { playingNow:true} })\nconst gameOff: Action<SDSContext, SDSEvent> = assign((context) => { return { playingNow:false} })\n\n//Initiate a questions object & assign values to context.letter/questions/tally\nconst newGameRound: Action<SDSContext, SDSEvent> = assign((context) => { \n    let qs=makeNewQuestions();\n    return { letter: qs.letter, questions: qs.ques, tally:0, confettiSwitch:false} \n})\n\n\n//Say the current random letter and a 'spelling/phonetic' alphabet\nfunction letterNow(context:SDSContext){\n    let alphabet:any = {\n        'a':'Adam', 'b':'Bella', 'c':'Cindy', 'd':'Daniel', 'e':'Eva', 'f':'Francesca', 'g':'Gabriel', 'h':'Harry',\n        'i':'Ida', 'j':'Julia', 'k':'Kevin', 'l':'Laura', 'm':'Michael', 'n':'Nicole', 'o':'Oscar', 'p':'Paula',\n        'q':'Quebec', 'r':'Rachel', 's':'Sara', 't':'Tina', 'u':'unique', 'v':'Victoria', 'w':'window', 'x':'x-ray',\n        'y':'yesman', 'z':'zero'\n        }\n    let letter:string = context.letter\n    return `Your letter is ${letter.toUpperCase()} for ${alphabet[letter]}. `\n}\n\nfunction questionNow(context:SDSContext){\n    let category = context.questions[0].category //the question at front of array\n    return `Name ${category}. `\n}\n\nfunction giveHint(context:SDSContext){\n    let answers = context.questions[0].answers //answers to the question at front of array\n    let anAns = randomChoice(answers)\n    if (anAns.length >= 3) {\n        let hint = anAns.slice(0, 3).toUpperCase() //first 3 letters\n        return `Spelled with ${hint[0]}, ${hint[1]}, ${hint[2]}.`\n    }\n    //in case word is too short>>hint only 2 letters\n    else {\n        let hint = anAns.slice(0, 2).toUpperCase() //first 2 letters\n        return `Spelled with ${hint[0]}, ${hint[1]}, ${hint[2]}.`\n    }\n}\n\n//Partial match of user input, as long as input mentions an answer\nfunction answerMatches(input:string,context:SDSContext){\n    let reply = input.toLowerCase() //convert to lowercase\n    let replySing = nounInflector.singularize( reply ) //convert to singular form\n\n    let answers = context.questions[0].answers //answers to the question at front of array\n\n    //True if reply--either original or singularised--mentions an answer \n    //(eg, 'the Netherlands' matches 'netherlands'; 'these strawberries' matches 'strawberry')\n    return  (exists(reply, answers) || exists(replySing, answers)) \n}\n\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction sharedRecognitions() {\n    return [\n        { target: 'stop', cond: (context:SDSContext) => sayKeyword(context.recResult) === 'stop' },\n        { target: 'restart', cond: (context:SDSContext) => sayKeyword(context.recResult) === 'restart' },\n        //for testing \n        { target: 'winning', cond: (context:SDSContext) => sayKeyword(context.recResult) === 'shortcut' },\n        { target: \".nomatch\" }\n        ]\n}\n\nfunction promptAndAsk(promptEvent: Action<SDSContext, SDSEvent>): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: promptEvent,\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: send('LISTEN'),\n            },\n            nomatch: { entry: [say(\"Try again\")],  \n                       on: { ENDSPEECH: \"prompt\" } \n            },\n        }\n    })\n}\n\n\n// Similar to python: any(keyword in input for keyword in keywords)\nfunction exists(input:string, keywords:string[]){\n    let existence = keywords.some(keyword => input.includes(keyword))\n    return existence\n}\n//Replace this with grammar parser?\nfunction sayKeyword(reply: string){\n    let yes=[\"yes\", \"of course\", \"sure\", \"absolutely\", \"yeah\", \"yep\", \"okay\", \"ok\"]\n    let no=[\"no\", \"nope\", \"no thanks\", \"nah\",]\n    let pass=[\"skip\", \"pass\", \"next\",]\n    let hint=[\"hint\", \"clue\", \"help\"]\n    let whatletter=['letter','repeat']\n    let stop=['stop','end the game','shut down']\n    let restart=['restart','start again', 'reboot']\n    let shortcut=['short cut', 'shortcut'] //for testing\n\n    reply=reply.toLowerCase()\n    if(exists(reply, yes)){ return 'yes' }\n    if(exists(reply, no)){ return 'no' }\n    if(exists(reply, pass)){ return 'pass' }\n    if(exists(reply, hint)){ return 'hint' }\n    if(exists(reply, whatletter)){ return 'whatletter' }\n    if(exists(reply, stop)){ return 'stop' }\n    if(exists(reply, restart)){ return 'restart' }\n    if(exists(reply, shortcut)){ return 'shortcut' } //for testing\n}\n\n/*\nNOTES\nSwear words are censored so won't match. Unless change them to f*** in the JSON\n? Find out how to show prompts & recognised text on screen\n? Confetti effect in winning state\n! Need to lemmatize userinput. Use js-lemmatizer, Natural, and/or Wink libraries \n*/\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'start'\n            }\n        },\n        stop: {\n            entry: say(\"Ok bye!\"),\n            on: { ENDSPEECH: {\n                actions: [resetTally,clearLetter,clearTTSAgenda,clearRecResult,confettiOff],\n                target:\"init\",\n                } \n            }\n        },\n        //Start new game: initiate new game object & reset tally counter\n        start: {\n            entry: say(\"Starting the game \"),\n            on: { ENDSPEECH: {\n                actions: [newGameRound, gameOn, clearTTSAgenda, clearRecResult],\n                target:\"sayletter\",\n                } \n            } \n        },\n        restart: {\n            entry: say(\"Ok, starting over\"),\n            // always: 'sayletter'\n            on: { ENDSPEECH: {\n                    actions: [newGameRound, clearTTSAgenda, clearRecResult],\n                    target:\"sayletter\",\n                    } \n            } \n        },\n        //Say the letter\n        sayletter:{\n            entry: send((context)=>({ type: \"SPEAK\", value: letterNow(context) })),\n            on: {ENDSPEECH:'askQues' }\n        },\n\n        //Ask 5 (or more if skipping) questions \n        askQues: {\n            on: {\n                RECOGNISED: [\n                    \n                    // ? Clear recResult after recognition or not...?\n                    // If answer matches answers, tally+=1, shift question[0]\n                    {cond: (context:SDSContext) => answerMatches(context.recResult, context),\n                     actions: assign((context:SDSContext) => { \n                        context.questions.shift()\n                        return { tally: context.tally+1 } }),\n                     target:\"checkscore\"  },\n                    \n                    //If pass, move the question to the last (unshift & push)\n                    {cond: (context:SDSContext) => sayKeyword(context.recResult)==='pass',\n                     actions: assign((context:SDSContext) => { \n                        let skipped=context.questions.shift();\n                        context.questions.push(skipped);\n                        return { } }),\n                     target:\"checkscore\"  },\n\n                    //Hint 3 or 2 letters\n                    {cond: (context:SDSContext) => sayKeyword(context.recResult)==='hint', target:\"hint\"},\n                    //Repeat letter\n                    {cond: (context:SDSContext) => sayKeyword(context.recResult)==='whatletter', target:\"sayletter\"},\n\n                    //Else    \n                    ...sharedRecognitions(),\n                    \n                ]},\n                ...promptAndAsk( send((context)=>({ type: \"SPEAK\", \n                                                    value: questionNow(context) })) )\n        },\n\n        hint: {\n            entry: send((context)=>({ type: \"SPEAK\", value: giveHint(context) })),\n            always: 'checkscore'\n        },\n        \n        checkscore:{\n            always: [\n                //Less than 5 correct\n                { target: 'askQues', cond: (context) => context.tally<5 },\n\n                //5 correct\n                { target: 'winning', cond: (context) => context.tally>=5 },\n            ]\n        },\n\n                    //? reset/clear tally here or not...? \n        winning: {\n            entry: [ say(\"Winner winner chicken dinner\"), confettiOn, clearLetter, clearRecResult, clearTTSAgenda ], \n            on: {ENDSPEECH:{target:'playagain'}}\n        },\n        playagain: {\n            entry: [ resetTally, confettiOff ],\n            on: {\n                RECOGNISED: [\n                     //Play again? restart:stop\n                     {cond: (context:SDSContext) => sayKeyword(context.recResult)==='yes', target:\"restart\"},\n                     {cond: (context:SDSContext) => sayKeyword(context.recResult)==='no', target:\"stop\"},\n\n                    //Else    \n                    ...sharedRecognitions() \n                ]},\n                ...promptAndAsk( say('Want to play again?') )\n        }, \n        \n    },\n\n})"]},"metadata":{},"sourceType":"module"}